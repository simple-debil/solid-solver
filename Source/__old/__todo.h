#if false
{
}
1) тест с трещиной не вплотную к границе материала (FEM)
2) тест с трещиной вплотную к границе материала (XFEM, FEM)



1) трещина с заданным интерфейсом
2) все базисные функции - интерполянты (в том числе лагранжевы ф-и)
gn_ и _gen будут финальными, остальное удалить

vertexBusFuncInd -> DOFs
vertexBusFuncInd->fs[vi[mn]][0] -> vertexBusFuncInd->fs[vi[mn]][FuncType::linear]
globalFuncIndex -> DOFindex



где подправить:
Grid::FEType::LinearHexagon_XFEM
gn_moveSubVertexes добавить в интерфейс
FE_LinearHexagon_XFEM::gn_initSubVertexes - значения ф-й находятся через жопу, если несколько трещин в одном КЭ


// типы базисных ф-й
enum class FuncType: size_t
{
    linear = 0,
    H = 1,
    tip1 = 2,
    tip2 = 3,
    tip3 = 4,
    tip4 = 5,
};


    1) Для узлов
// Нумерация базисных ф-й
struct FuncSource_gen
{
    FuncType type;     // тип базисной ф-и
    VECTOR3_int DOF_index;  // индексы степеней свободы для базисной ф-и funcIndex (по x, y, z)
};
std::vector<std::vector<FuncSource_gen>> fs; // fs[vertexIndex][funcSourceIndex].DOF_index - индексы степеней свободы для базисной ф-и fs[vertexIndex][funcSourceIndex].type



    2) Для КЭ
// Массив типов базисных ф-й, которые заданы на КЭ (будут строится их интерполянты)
struct FuncID
{
    FuncType type; // тип базисной ф-и
    // size_t crackIndex;   // индекс трешины
};
std::vector<FuncID> funcsID;       // funcsID[funcsIDIndex].type - тип базиснойой ф-и

// Локальная нумерация базисных ф-й
struct DOF_ID
{
    size_t lvi;     // локальный индекс узла, в котором задана базисная ф-я
    size_t fs_index;        // fs[vi[lvi]][fs_index].type - тип базисной ф-и, fs[vi[lvi]][fs_index].DOF_index - глобальные степени свободы (по x, y, z)
    size_t funcID_index;    // funcsID[funcID_index].type - тип базисной ф-и, funcID_index - индекс интерполянта
    // size_t crackIndex;   // индекс трешины
};
std::vector<DOF_ID> DOFs_ID;       // funcsID[funcsIDIndex].type - индекс базисной ф-и,
















некоторые строки матрицы могут получиться нулевыми
Заранее задавать с какой стороны подобласть
стр 129

0) не правильно вычисляются результаты итераций(не учитывается, что некоторые ф-и вырублены)
1) рисовать линии уровня для проверки
2) задавать для XFEM-КЭ функции ls_tan, ls_norm,
и дополнительно ls_angle, ls_r
3) добавить ф-и для вершины
добавить ф-и для биматериала
3) добавить нумерацию и интегрирование произвольного набора базисных ф-й

4*) добавить функции уровня для произвольных поверхностей трещин
5*) добавить построение сетки внутри КЭ



20) убрать vertexForCurvature
21) тест с пластиной с отверстием
22) температура не работает с 3х3 решателем СЛАУ
23) перейти к формату хранения СЛАУ как в pardiso
24) убрать  Integration::Integrator





















































(
1. распараллелить вывод графиков
если на последней итерации шага было отлипание, то далее будет зацикливаться и не завершаться сразу даже если b=0
первые краевые сделать нормально хотя бы однородные
время выводится херова
количество разложений матрицы выводится на 1 больше если после последней итерации требуется перестраивать матрицу
добавить w_R
количество потоков - параметр решения слау
)

3* реализовать метод Ньютона-Рафсона/Канторовича
4* разобраться с ползучестью и большими деформациями
5. стахостическая теория ползучести






если есть первые краевые, то в любом случае пересобирать матрицу, т.к. они влияют на вектор
В вектор невязок R не может попасть мусор на 0-й итерации 0-го шага

продолговатая и более простая сетка

СЛАУ: развернуть внутренний цикл в предобусловливании
    в случае 3х3 ссылка на нулевую матрицу 3х3
расчёт давлений: медленно собирается матрица
цилиндр: f_sigma1 - sigma_z
         f_sigma2,f_sigma3 - сделать sigma_x, sigma_y, сейчас не понятно что

плоская пластичность


может не надо использовать метод крамера(для 2-х краевых), устойчивость вычислительная


 сделать чтобы после прерывания можно было посмотреть картинку

 в исходном алгоритме вообще нет суммарных напряжений и деформаций(только приращения и девиатор расчитывается исходя из полных напряжений)

сила то приложена, значит ндс может полсти в полных силах, просто параметры материала будут меняться
прирост ползучей деформации вычислять по результатам прошлого шага, для устойчивости
какую пластическую деформацию нужно приложить, чтобы добавленные силы изменили эквивалентную деформацию на требуемое приращение?(в поезде писал формулки)
если выделить только упругие деформации то должно получиться равновесие

*сохранение сетки
*проверить 2d пластичность на задаче Кирша
*проверить нагружение балки, раньше выдавалось точное решение для квадратичной кривой деформирования

I) тесты контакт + упругость/пластичность
 сетка
  вложить ещё уровень сгущения
 перерасчёт сил в давление
  после пересчёта узловых сил в давление на границе давление плавно понижается до нуля, регуляризовать?

II) ползучесть
 растяжение ползучего цилиндра
 *определяющие соотношения: упруго-пластичность и ползучесть совместить в разных слагаемых
 ползучесть: вдавливание шара в ползучее полупространство

III) геометрическая нелинейность
 https://en.wikiversity.org/wiki/Nonlinear_finite_elements/Updated_Lagrangian_approach
 *тест на изгиб?
 *геометрическая нелинейность (Ax=b-R - модифицированная схема шагового нагружения с коррекцией погрешности - вроде не рабочая)
 может быть всё-таки integral(sigma) = sum(G*deltaP - b)
 размывается сетка из-за вычитания суммарных напряжений
 сдвиг сетки: повотор тензоров, материальные производные, большие деформации







НДС:
    формовка: на лагранжевом сплайне возникает пластичность даже с ограничением elasticSigmaLimit = 2.e100; Сделать разгрузку упругой чтобы стало чётко??
    интерполянты лагранжа - сходится быстро, эрмита - медленно (наверно поиск ближайшей точки лагранжа почти дискретный)
    добавить тетраэдры и призмы

Температура:
    деформации температурного расширения добавлять в R? (вроде нет)
    для изотропного тела вектор температурных деформаций равен (e, e, e, 0, 0, 0)??
    для плосконапряжённого состояния температурная деформация домножается на (1 + NU)
    (Зарубин В.С., Станкевич И.В. - Расчет теплонапряженных конструкций-Издательство _Машиностроение_ (2005), стр. 195)
    1) добавить к кривым зависимость от температуры
    2) согласованность упругих параметров и кривой (менять начальный наклон и т.п.)
    3) изменение температуры влияет только на упругие деформации?

Визуализация:
    OpenGL или Vulcan 3d картинка
    статистика выремени выполнения странная(в случае пересчёта предобусловливателя дублировать информацию об итерации), выводить в дирректорию теста
    1) сделать норм qt сетку для графиков
    2) логгер: sync() чтобы завершить все задачи
    3) выводить гистограммы вычислительных затрат
    4) рисовать портреты матриц
    5) графики кривых пластичности и производной

Оптимизация:
    требуемые невязки - это параметр материала
    невязки по контакту (contactDeltaFResidualLimit) относятся к контактной паре, а не к шагу(MechGlobalStepParameters)
    ?вычислять компоненты деформаций только после завершения итераций
    завершение итераций (когда слау перестаёт меняться? дожимать?)
    0) elementary.h - разобрать помойку
    1) некоторые значения с предыдущей итерации можно не хранить
    сделать симметричные матрицы 3х3 на диагонали (вдруг численная устойчивость может хромать? Действительно, контактная матрица добавлялась не максимально симметрично и это влияло на решение!!!)


    //-----------------------------------------
    // (difSigma и difEps возвращают tan_betta)
    // (специальные случаи: sigma = 0)

  // чекнуть MechFeData_base и MechFePointData
  // MechFeData_base с разными структурами MechFePointData (для 3-х материалов)
  // названия:
  // enum class: type -> method
#endif
